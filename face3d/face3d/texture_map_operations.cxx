#include "texture_map_operations.h"
#include <cmath> // for isnan()

#include <dlib/geometry.h>
#include <dlib/matrix.h>
#include <dlib/pixel.h>
#include <dlib/image_transforms.h>
#include <igl/AABB.h>
#include <igl/barycentric_coordinates.h>
#include <vgl/vgl_triangle_scan_iterator.h>

float weight_original(float original_vis, float aug_vis)
{
  // weight original vs. mirrored using sigmoid
  // The weights are generated by the following sigmoid function which satisfies the desirada:
  // heavily weight the original image (i.e. f~1.0) when vis_score >> 0
  // heavily weight the mirror image (i.e. f~0.0) when vis_score is close to 0 and mirrored_vis_score >> 0
  // f = 1/(1 + exp(-s*(a*vis_score - mirrored_vis_score)))
  const float m = 1.1; // controls the slope of the isoline f=0.5.
  // e.g., m=1.0 weights mirrored and original observations equally based on number of observations.
  // m > 1.0 weights original observation higher given equal number of observations
  const float s = 10.0f; // controls the sharpness off the transition from f=0 to f=1
  const float v = 0.6f; // beyond this value, use only original observation
  // increase the transition sharpness as aug_vis gets smaller.  This is to avoid weights < 1 when aug_vis is close to zero.
  float w1_slope_mod = 1.0/(aug_vis*original_vis+0.01); 
  float inv_weight1 = 1.0/(1.0 + std::exp( -s*w1_slope_mod * (aug_vis - m*original_vis) ) );
  float inv_weight2 = 1.0/(1.0 + std::exp( -s * (v - original_vis) ));
  return 1.0f - inv_weight1*inv_weight2;
}


unsigned char interpolate_value(unsigned char v1, unsigned char v2, float w1)
{
  float fv1 = static_cast<float>(v1);
  float fv2 = static_cast<float>(v2);
  float fresult = w1*fv1 + (1.0-w1)*fv2;
  if (fresult < 0) fresult = 0;
  if (fresult > 255) fresult = 255;
  return static_cast<unsigned char>(fresult);
}

dlib::rgb_pixel interpolate_pixel(dlib::rgb_pixel const& v1, dlib::rgb_pixel const& v2, float w1)
{
  dlib::rgb_pixel result;
  result.red = interpolate_value(v1.red, v2.red, w1);
  result.green = interpolate_value(v1.green, v2.green, w1);
  result.blue = interpolate_value(v1.blue, v2.blue, w1);
  return result;
}

void extract_alpha(dlib::array2d<dlib::rgb_alpha_pixel> const& img,
                   dlib::array2d<dlib::rgb_pixel> &color,
                   dlib::array2d<float> &alpha)
{
  const int nx = img.nc();
  const int ny = img.nr();
  alpha.set_size(ny,nx);
  color.set_size(ny,nx);
  for (int y=0; y<ny; ++y) {
    for (int x=0; x<nx; ++x) {
      unsigned char alpha_val = img[y][x].alpha;
      color[y][x] = dlib::rgb_pixel(img[y][x].red, img[y][x].green, img[y][x].blue);
      alpha[y][x] = static_cast<float>(alpha_val)/255;
    }
  }
}

void bleed_color(dlib::array2d<dlib::rgb_alpha_pixel> &img, int region_radius=4)
{
  const int nx = img.nc();
  const int ny = img.nr();
  dlib::array2d<dlib::rgb_alpha_pixel> work(ny,nx);
  dlib::assign_image(work, img);
  for (int y=region_radius; y<(ny-region_radius); ++y) {
    for (int x=region_radius; x<(nx-region_radius); ++x) {
      if (img[y][x].alpha < 1.0) {
        dlib::rgb_alpha_pixel pix = img[y][x];
        dlib::matrix<float,0,1> og_rgba {static_cast<float>(pix.red),
          static_cast<float>(pix.blue),
          static_cast<float>(pix.green),
          static_cast<float>(pix.alpha)/255.0f};
        // search over neighbors
        dlib::matrix<float,0,1> neighbor_rgba {0.0f, 0.0f, 0.0f, 0.0f};
        float max_neighbor_weight = 0.0f;
        for (int yn=(y-region_radius); yn < (y+region_radius); ++yn) {
          for (int xn=(x-region_radius); xn < (x+region_radius); ++xn) {
            dlib::rgb_alpha_pixel npix = img[yn][xn];
            float weight = static_cast<float>(npix.alpha)/255.0;
            neighbor_rgba(0) += weight*static_cast<float>(npix.red);
            neighbor_rgba(1) += weight*static_cast<float>(npix.green);
            neighbor_rgba(2) += weight*static_cast<float>(npix.blue);
            neighbor_rgba(3) += weight;
            if (weight > max_neighbor_weight) max_neighbor_weight = weight;
          }
        }
        float weight_sum = neighbor_rgba(3);
        if (weight_sum > 0.0f) {
          neighbor_rgba /= weight_sum;
          neighbor_rgba(3) = max_neighbor_weight; // std::min(1.0f, weight_sum);
          float og_weight = weight_original(og_rgba(3), neighbor_rgba(3));
          dlib::matrix<float,0,1> new_rgba = og_weight*og_rgba + (1.0-og_weight)*neighbor_rgba;
          new_rgba(3) *= 255;
          //new_rgba(3) = std::min(og_rgba(3), neighbor_rgba(3)) * 255.0f;
          dlib::rgb_alpha_pixel
            new_pix(static_cast<unsigned char>(std::max(0.0f,std::min(255.0f,new_rgba(0)))),
                    static_cast<unsigned char>(std::max(0.0f,std::min(255.0f,new_rgba(1)))),
                    static_cast<unsigned char>(std::max(0.0f,std::min(255.0f,new_rgba(2)))),
                    static_cast<unsigned char>(std::max(0.0f,std::min(255.0f,new_rgba(3)))));
          work[y][x] = new_pix;

        }
      }
    }
  }
  std::swap(work,img);
}

void face3d::merge_textures(std::vector<dlib::array2d<dlib::rgb_alpha_pixel> > const& textures,
                            dlib::array2d<dlib::rgb_alpha_pixel> &merged)
{
  const int num_textures = textures.size();
  if (num_textures == 0) {
    std::cerr << "WARNING: Empty vector passed to merge_textures." << std::endl;
    return;
  }
  const int tex_nr = textures[0].nr();
  const int tex_nc = textures[0].nc();

  // verify that all inputs have same size
  for (int t=1; t<num_textures; ++t) {
    if ((textures[t].nr() != tex_nr) || (textures[t].nc() != tex_nc)) {
      throw std::runtime_error("Textures of different size passed to merge_textures()");
    }
  }
  merged.set_size(tex_nr, tex_nc);
  for (int r=0; r<tex_nr; ++r) {
    for (int c=0; c<tex_nc; ++c) {
      unsigned char max_alpha = 0;
      double weight_sum = 0.0;
      double color[3] = {0,0,0};
      for (int t=0; t<num_textures; ++t) {
        dlib::rgb_alpha_pixel pix(textures[t][r][c]);
        if (pix.alpha > max_alpha) {
          max_alpha = pix.alpha;
        }
        // use softmax on alpha channel to weight inputs
        const double softmax_weight = 10.0;
        double weight = std::exp(softmax_weight * static_cast<double>(pix.alpha)/255.0);
        weight_sum += weight;
        color[0] += weight*static_cast<double>(pix.red);
        color[1] += weight*static_cast<double>(pix.green);
        color[2] += weight*static_cast<double>(pix.blue);
      }
      dlib::rgb_alpha_pixel pix_out(0,0,0,0);
      if (weight_sum > 1e-3) {
        pix_out.red = static_cast<unsigned char>(std::max(0.0,std::min(255.0,color[0]/weight_sum)));
        pix_out.green = static_cast<unsigned char>(std::max(0.0,std::min(255.0,color[1]/weight_sum)));
        pix_out.blue = static_cast<unsigned char>(std::max(0.0,std::min(255.0,color[2]/weight_sum)));
        pix_out.alpha = max_alpha;
      }
      merged[r][c] = pix_out;
    }
  }
}

void face3d::complete_texture(dlib::array2d<dlib::rgb_alpha_pixel> const& tex,
                              dlib::array2d<dlib::vector<float,2> > const& sym_map,
                              dlib::array2d<dlib::rgb_alpha_pixel> &tex_completed)
{
  const int nx = tex.nc();
  const int ny = tex.nr();
  tex_completed.set_size(ny,nx);
  dlib::assign_all_pixels(tex_completed, dlib::rgb_alpha_pixel(0,0,0,0));

  // bleed outer edge of texture to prevent artifacts at seams
  dlib::array2d<dlib::rgb_alpha_pixel> tex_bled(ny,nx);
  dlib::assign_image(tex_bled, tex);
  bleed_color(tex_bled);

  dlib::interpolate_bilinear interp;
  // interp requires pixel type without alpha
  dlib::array2d<dlib::rgb_pixel> tex_no_alpha;
  dlib::array2d<float> tex_alpha;
  extract_alpha(tex_bled, tex_no_alpha, tex_alpha);
  dlib::image_view<dlib::array2d<dlib::rgb_pixel>> tex_no_alpha_img(tex_no_alpha);
  dlib::image_view<dlib::array2d<float> > alpha_img(tex_alpha);

  for (int y=0; y<ny; ++y) {
    for (int x=0; x<nx; ++x) {
      dlib::vector<float,2> sym_loc_uv = sym_map[y][x];
      if (std::isnan(sym_loc_uv.x()) || std::isnan(sym_loc_uv.y())) {
        tex_completed[y][x] = tex_bled[y][x];
        continue;
      }
      dlib::vector<float,2> sym_loc_pix( sym_loc_uv.x()*nx, (1.0 - sym_loc_uv.y())*ny);
      dlib::rgb_alpha_pixel color = tex_bled[y][x];
      float alpha_og = static_cast<float>(color.alpha)/255;
      float alpha_sym;
      interp(alpha_img, sym_loc_pix, alpha_sym);

      float alpha_out = vnl_math::min(1.0, static_cast<double>(alpha_og+alpha_sym));
      if (alpha_out > 1e-3) {
        float weight = weight_original(alpha_og, alpha_sym);
        dlib::rgb_pixel sym_color;
        interp(tex_no_alpha_img, sym_loc_pix, sym_color);
        dlib::rgb_pixel color_out = interpolate_pixel(tex_no_alpha[y][x], sym_color, weight);
        dlib::assign_pixel(tex_completed[y][x],color_out);
      }
      tex_completed[y][x].alpha = static_cast<unsigned char>(alpha_out*255);
    }
  }
  bleed_color(tex_completed);
}

void face3d::generate_face_symmetry_map(face3d::head_mesh const& base_mesh,
                                        dlib::array2d<dlib::vector<float,2> > &sym_map)
{
  auto face_mesh = base_mesh.face_mesh();
  generate_symmetry_map(face_mesh.V(), face_mesh.F(), face_mesh.T(),
                        face_mesh.texture().nc(), face_mesh.texture().nr(),
                        sym_map);
}

void face3d::generate_symmetry_map(triangle_mesh::VTYPE const& V, triangle_mesh::FTYPE const& F,
                                   triangle_mesh::TTYPE const& UV, int tex_nx, int tex_ny,
                                   dlib::array2d<dlib::vector<float,2> > &sym_map)
{
  igl::AABB<triangle_mesh::TTYPE,2> tex_mesh_tree;
  tex_mesh_tree.init(UV, F);

  igl::AABB<triangle_mesh::VTYPE,3> mesh_tree;
  mesh_tree.init(V,F);

  sym_map.set_size(tex_ny, tex_nx);
  // for each pixel in the texture map
  for (int y=0; y<tex_ny; ++y) {
    for (int x=0; x<tex_nx; ++x) {
      // unmapped pixels will be written as NANs
      sym_map[y][x] = dlib::vector<float,2>(NAN,NAN);

      // convert image coordinates to normalized texture coords
      double u = static_cast<double>(x) / tex_nx;
      double v = 1.0 - (static_cast<double>(y) / tex_ny);

      // find the face and barycentric coordinates using texture coordinates
#if 0
      Eigen::Matrix<double,1,2> query_points2d(u,v);
      Eigen::Matrix<double,1,1> query_dists2d;
      Eigen::Matrix<int,1,1> face_indices2d;
      Eigen::Matrix<double,1,2> closest_points2d;
#else
      Eigen::MatrixXd query_points2d(1,2);
      query_points2d(0,0) = u;
      query_points2d(0,1) = v;
      Eigen::MatrixXd query_dists2d;
      Eigen::MatrixXi face_indices2d;
      Eigen::MatrixXd closest_points2d;

#endif
      tex_mesh_tree.squared_distance(UV, F, query_points2d, query_dists2d, face_indices2d, closest_points2d);
      // 2d mesh, so we can expect query points to lie exactly on triangles
      if (query_dists2d(0) <= 1e-6) {
        // get the points
        Eigen::MatrixXd barycentric_coords;
        Eigen::MatrixXi vert_indices = F.row(face_indices2d(0));

        // compute the barycentric coordinates of the query point wrt the mesh face
        igl::barycentric_coordinates(query_points2d,
                                     Eigen::MatrixXd(UV.row(vert_indices(0))),
                                     Eigen::MatrixXd(UV.row(vert_indices(1))),
                                     Eigen::MatrixXd(UV.row(vert_indices(2))),
                                     barycentric_coords);

        // get corresponding 3-d point
        Eigen::MatrixXd pt3d =
          barycentric_coords(0)*V.row(vert_indices(0)) +
          barycentric_coords(1)*V.row(vert_indices(1)) +
          barycentric_coords(2)*V.row(vert_indices(2));

        // generate mirror image by flipping X coordinate
        Eigen::MatrixXd pt3d_mirrored(pt3d);
        pt3d_mirrored(0,0) = -pt3d(0,0);

        // find nearest mesh face to mirrored point
#if 0
        Eigen::Matrix<double,1,1> query_dists3d;
        Eigen::Matrix<int,1,1> face_indices3d;
        Eigen::Matrix<double,1,3> closest_points3d;
#else
        Eigen::MatrixXd query_dists3d;
        Eigen::MatrixXi face_indices3d;
        Eigen::MatrixXd closest_points3d;
#endif
        mesh_tree.squared_distance(V, F, pt3d_mirrored, query_dists3d, face_indices3d, closest_points3d);
        const double dist_thresh = 10.0;
        // 3d points may lie off of mesh if not perfectly symmetrical
        if (query_dists3d(0) <= dist_thresh) {
          // get the points
          Eigen::MatrixXd barycentric_coords;
          Eigen::MatrixXi vert_indices = F.row(face_indices3d(0));

          // compute the barycentric coordinates of the query point wrt the mesh face
          igl::barycentric_coordinates(pt3d_mirrored,
                                       Eigen::MatrixXd(V.row(vert_indices(0))),
                                       Eigen::MatrixXd(V.row(vert_indices(1))),
                                       Eigen::MatrixXd(V.row(vert_indices(2))),
                                       barycentric_coords);
          // get corresponding 2-d point in texture space
          Eigen::RowVector2d pt2d_mirrored =
            barycentric_coords(0)*UV.row(vert_indices(0)) +
            barycentric_coords(1)*UV.row(vert_indices(1)) +
            barycentric_coords(2)*UV.row(vert_indices(2));

          sym_map[y][x] = dlib::vector<float,2>(pt2d_mirrored(0),
                                                pt2d_mirrored(1));
        }
      }
    }
  }
}

void face3d::mask_mesh_faces(triangle_mesh const& mesh, dlib::array2d<unsigned char> const& texmask,
                             std::vector<size_t> &valid_faces)
{
  valid_faces.clear();
  const int nx = texmask.nc();
  const int ny = texmask.nr();
  // loop through each face of the mesh, checking for intersection with texmask pixels
  for (int fi=0; fi<mesh.num_faces(); ++fi) {
    bool good_face = false;
    std::array<int,3> face_verts = mesh.face(fi);
    vgl_triangle_scan_iterator<double> ti;
    vgl_point_2d<double> a = mesh.vertex_tex(face_verts[0]);
    vgl_point_2d<double> b = mesh.vertex_tex(face_verts[1]);
    vgl_point_2d<double> c = mesh.vertex_tex(face_verts[2]);
    ti.a.x = a.x()*nx; ti.a.y = a.y()*ny;
    ti.b.x = b.x()*nx; ti.b.y = b.y()*ny;
    ti.c.x = c.x()*nx; ti.c.y = c.y()*ny;
    // if any of the boundary points are within mask, don't bother scanning interior
    for (auto bp : {ti.a, ti.b, ti.c}) {
      int bx = static_cast<int>(bp.x);
      int by = ny - static_cast<int>(bp.y);
      if ((bx >= 0) && (bx < nx) && (by >= 0) && (by < ny) && texmask[by][bx]) {
        good_face = true;
      }
    }
    for(ti.reset(); ti.next();){
      if (good_face) {
        break;
      }
      int y = ny - ti.scany();
      if ( (y < 0) || (y >= ny) ) {
        continue;
      }
      for (int x = ti.startx(); x <= ti.endx(); ++x){
        if ( (x<0) || (x>=nx) ) {
          continue;
        }
        if (texmask[y][x] > 0) {
          good_face = true;
          break;
        }
      }
    }
    if (good_face) {
      valid_faces.push_back(fi);
    }
  }
  return;
}
